{:enums
 {:cue_var_type
  {:description "Types of cue-var"
   ; :values [:NUMBER :COLOR :XY]}}
   ; :values [:DOUBLE :COLOR :INTEGER :BOOL]}}
   :values [:double :color :integer :boolean]}}
 ;UNIT as a field duh. %, unity, meters, degrees...

 ; :interfaces
 ; {:ranged {:fields {:min {}
 ;                    :max {}}}
 ;  :categorized {:fields {:id {}
 ;                         :name {}
 ;                         :type {}}}}

; (def scalars
;   (schema/compile
;     {:scalars
;      {:GridPosition
;       {:parse #(try (apply vector (clojure.string/split % #" "))
;                    (catch Throwable _ nil))
;       ; {:parse #(when (string? %)
;       ;            (try (apply vector (clojure.string/split % #" "))
;       ;              (catch Throwable _ nil)))
;        :serialize #(try (str %) #_(str (first %) " " (second %))
;                      (catch Throwable _ nil))}}
;      :queries
;      {:pos
;       {:type :GridPosition
;        :args {:id {:type :Int}}
;        :resolve (fn [ctx args v] [0 7])} }}))
; (lacinia/execute scalars "{pos(id: 1) }" nil nil )
 :scalars {
  :Color {
          :tag thi.ng.color.core.HSLA
          :parse :str-to-clj-rec ;good for anything only containing scalar fields and no IFNs or whatever
          :serialize :clj-rec-to-str }}
 :objects {
  ; :fields {:id {:type (non-null ID)}
  ;          ; input Point2D { x: Float y: Float }
  ;          ; ^ there's float! also:
;;Int parser handles strings and all kinds of numbers (including non-integers).
  ;          ; :position {:input {:GridPosition {:x {:type Int} :y {:type Int} }}}
  ;          ;^ like so? or :fields or like how balance ze map?
          ;:fields
          ;{:a {:type Float} :h {:type Float}
          ; :s {:type Float} :l {:type Float}}

  :Cue {:description "Single cue definition"
   :fields {:id {:type String}
            :name {:type String}
            :priority {:type Int}
            :color {:type :Color}
            :position {:type (list Int)} ;how is non-null enforced?
            :current_color {:type :Color}
            :style_color {:type String}
            :held {:type Boolean}
            :variables {:type (list :Variable)}}}

  :Variable
  {:description "Single variable definition - child of a Cue"
   :fields {:key {:type String}
            :name {:type String}
            ; :value {:description "Current value, when cue is active or saved."
            ;         :type :cue_var_type
            ;         :resolve :get-active-cue-var}
            :type {:type :cue_var_type} ;or like, keyword
            ; :type {:type } ;or like, keyword
            :min {:type Float}
            :max {:type Float}}}
  :Control
  {:fields {:id {:type Int}
            :name {:type String}
            :for_type {:type String} ;or :type :type
            ; :usable_with {:type (list :cue_var_type)}}}}
            ; :usable_with {:type :cue_var_type}
            }}
  :Snapshot
  {:fields {:instant {:type Int}
            :beat {:type Int}
            :bar {:type Int}
            :phrase {:type Int}}
   :tag afterglow.rhythm.MetronomeSnapshot}}
            ; :usable_with {:type (list :Variable)}}}} ;uhh

; (({}, {})
;  ({}, {}))

 :queries
 {:cue_for_id {:type :Cue
               :args {:id {:type ID}}
               :resolve :get-cue-for-id}
  :cue_var {:type (non-null :Variable)
            :args {;:cue {:type :Cue} ;parent
                   :name {:type String :default-value "Level"}}
            :resolve :get-cue-var}
  :sin {:type Float :resolve :get-sin}
  :control {:type :Control
            :args {:id {:type ID :default-value "1000"}}
            :resolve :get-control}
  ; :cue_var_values {:description "Current values for all active cue vars"
  ;                  :resolve :get-cue-var-values}

  :cues {:type (list :Cue)
         ; :args {:size {:type Int }
         ;        :page {:type (list Int) }
         ;        :offset {:type (list Int) }}
         ; :args {:size {:type Int :default-value 8}
         ;        :page {:type (list Int) :default-value [0 0]}
         ;        :offset {:type (list Int) :default-value [0 0]}}
         :args {:size {:type Int :default-value 8}
                :cell_offset {:type (list Int) :default-value [0 0]}}
         :resolve :get-cue-grid}}

 :subscriptions
 {:sins {:type Float
         :stream :stream-sin}
  :running {:type Boolean :stream :running}
  #_:vars_for_cue #_{:type (list :VariableState)
                 :stream :stream-vars-for-cue}}

:mutations
{  }}

